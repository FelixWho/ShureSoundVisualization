<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Waveform</title>
</head>
<body>
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<script src="../three.min.js"></script>
<script src="../jquery-3.4.1.min.js"></script>
<script>
function startListening() {



    navigator.mediaDevices.getUserMedia({audio: true, video: false}).then(stream => {

        // test rolling Q

        // let testQ = new RollingQueue(3);
        //
        // for(let i = 1; i < 6; i ++) {
        //     console.log(testQ.add(i));
        // }

        const context = new AudioContext();
        const source = context.createMediaStreamSource(stream);

        // server side
        var sessionID = "7";
        var postUrl = "";

        function urlInit() {
            const req = new XMLHttpRequest();
            req.open("POST", "http://35.193.212.185/api/init", true);
            req.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
            req.send(JSON.stringify({rate: context.sampleRate, sessionID: sessionID, location: ""}));

            req.addEventListener("load", urlCallback, false);
        }

        function urlCallback(event) {

            let data = JSON.parse(event.target.responseText);
            console.log(data);
            console.log("success", data.success);

            postUrl = data.url;
        }

        urlInit();



        const processor = context.createScriptProcessor(16384, 1, 1);

        source.connect(processor);

        const fakeDestination = context.createMediaStreamDestination();

        processor.connect(fakeDestination);

        let index = 0;
        // processor.onaudioprocess = event => {
        //     // console.log(event);
        //
        //     let data = event.inputBuffer.getChannelData(0);
        //     // console.log(data);
        //
        //     let dataString = "[" + data.join(",") + "]";
        //
        //     const packet = {"data" : dataString, "index" : index++};
        //     //console.log("packet: "+JSON.stringify(packet));
        //     const xmlHttp = new XMLHttpRequest();
        //     xmlHttp.open("POST", "http://35.193.212.185" + postUrl, true);
        //     xmlHttp.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        //     xmlHttp.send(JSON.stringify(packet));
        //
        //     xmlHttp.addEventListener("load", callback, false);
        // };

        function callback(d) {
            console.log(d);
        }

        const analyzer = context.createAnalyser();

        analyzer.fftSize = 2048;
        // analyzer.minDecibels = -100;
        // analyzer.maxDecibels = -10;
        analyzer.smoothingTimeConstant = 0.8;

        source.connect(analyzer);
        analyzer.connect(fakeDestination);


    let isListener = false;
    let camera, scene, renderer;
    let geometry, material, mesh;

    const BINS = 3;
    var meshes = [];

    function init() {

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        camera.position.z = 3;

        scene = new THREE.Scene();
        material = new THREE.MeshNormalMaterial();


        for(let i = 0; i < BINS; i++ ) {
            geo = new THREE.CubeGeometry(0.1, 0.1, 0.1);

            meshes[i] = new THREE.Mesh(geo, material);

            scene.add(meshes[i]);

            meshes[i].position.set(i - (BINS-1)/2, 0, 0);
        }

        renderer = new THREE.WebGLRenderer( {antialias: true, alias: true} );
        renderer.setSize( window.innerWidth, window.innerHeight );

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
    }

    init();


    var data = [];



    const QSIZE = 32;
    let means = new Float64Array(analyzer.frequencyBinCount);
    let squares = new Float64Array(analyzer.frequencyBinCount);
    let variance = new Float64Array(analyzer.frequencyBinCount);

    for(let i = 0; i < analyzer.frequencyBinCount; i++) {
        data[i] = new RollingQueue(QSIZE);
        means[i] = 0;
        squares[i] = 0;
        variance[i] = 0;
    }

    let bins = new Array(BINS + 1);

    // console.log(bins);

    function animate() {
        let buf = new Float32Array(analyzer.frequencyBinCount);
        analyzer.getFloatFrequencyData(buf);

        let totalVariance = 0.0;

        for(let i = 0; i < analyzer.frequencyBinCount; i++) {
            let element = buf[i] / QSIZE;
            if(!isNaN(element) && isFinite(element)) {

                // console.log(element);

                means[i] += element;
                squares[i] += element * element;

                // adds it to the data... and gets the data element that is no longer relevant.
                let lastElement = data[i].add(element);

                means[i] -= lastElement;
                squares[i] -= lastElement * lastElement;

                variance[i] =  QSIZE * squares[i] - means[i] * means[i];

                totalVariance += variance[i];
            }
        }


        console.log(variance);

        let runningVariance = 0;

        bins = [0];

        for(let i = 0; i < analyzer.frequencyBinCount; i++) {
            runningVariance += variance[i];

            if(runningVariance >= totalVariance/BINS || i === analyzer.frequencyBinCount - 1) {
                bins.push(i);
                runningVariance -= totalVariance/BINS;
            }
        }


        arr = bins;

        // console.log(arr);

        for(let i = 0; i < BINS; i++) {
            let width = bins[i+1] - bins[i];

            let theMean = 0;
            let theVariance = 0;
            let theVal = 0;

            for(let j = bins[i]; j < bins[i+1]; j++) {
                theMean += means[i];
                theVariance += variance[i];
                theVal += buf[i];
            }
            theMean /= width;
            theVariance /= width;
            theVal /= width;


            let zscore = (theVal + 100)/90;

            console.log(zscore);

            let scale = 1 + 4*Math.min(Math.max(zscore, 0), 1);

            meshes[i].scale.x = scale;
            meshes[i].scale.y = scale;
            meshes[i].scale.z = scale;
        }

        //console.log(avg);

        // setInterval(analyze, 50);

        requestAnimationFrame( animate );

        meshes[0].rotation.x += 0.01;
        meshes[0].rotation.y += 0.01;
        meshes[1].rotation.x -= 0.01;
        meshes[1].rotation.y += 0.01;
        meshes[2].rotation.x -= 0.01;
        meshes[2].rotation.y -= 0.01;


        renderer.render( scene, camera );

    }

    let arr =  [14,26, 40,60];
    animate();
        
    });
}

    function listener(event){ // user chose listener role
        isListener = true;
        startListening();

        let back = document.createElement("INPUT");
        back.type = "submit"; back.value = "back";
        back.addEventListener("click", function(event){
            location.reload(false);
        })
        document.body.insertBefore(back, document.getElementById("listener"));

        if(document.getElementById("listener")){
            document.getElementById("listener").remove();
        }
        if(document.getElementById("player")){
            document.getElementById("player").remove();
        }
    }

    function player(event){ // user chose player role

        isListener = false;

        let back = document.createElement("INPUT");
        back.type = "submit"; back.value = "back";
        back.addEventListener("click", function(event){
            location.reload(false);
        })
        document.body.insertBefore(back, document.getElementById("listener"));
        
        if(document.getElementById("listener")){
            document.getElementById("listener").remove();
        }
        if(document.getElementById("player")){
            document.getElementById("player").remove();
        }
        
    }

    class RollingQueue {
        constructor(size) {
            this.size = size;
            this.array = new Float64Array(this.size);

            this.index = 0;
        }

        add(element) {
            let lastElement = this.array[this.index];
            this.array[this.index] = element;
            this.index = (this.index + 1) % this.size;

            return lastElement;
        }

    }

</script>

<input type = "submit" id = "listener" value = "listener">
<input type = "submit" id = "player" value = "player">

<script>
    /* EVENT LISTENERS */
    document.getElementById("listener").addEventListener("click", listener, false);
    document.getElementById("player").addEventListener("click", player, false);
</script>

</body>
</html>